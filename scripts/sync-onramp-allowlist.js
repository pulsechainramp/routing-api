#!/usr/bin/env node
/**
 * Generates vetted onramp provider host allowlists for both the routing API
 * and the aggregator frontend. Hosts are derived from the canonical
 * routing-api onramps catalog so that product teams only maintain one source
 * of truth.
 */
const fs = require("node:fs");
const path = require("node:path");

const API_ROOT = path.resolve(__dirname, "..");
const WORKSPACE_ROOT = path.resolve(API_ROOT, "..");

const PROVIDERS_JSON = path.join(
  API_ROOT,
  "src",
  "data",
  "onramps_providers.json"
);

const FRONTEND_TARGET = path.join(
  WORKSPACE_ROOT,
  "aggregator-frontend",
  "src",
  "data",
  "allowedProviderHosts.ts"
);

const API_TARGET = path.join(
  API_ROOT,
  "src",
  "data",
  "allowedProviderHosts.ts"
);

const HTTP_REGEX = /^https?:\/\//i;

const normalizeHost = (host) => host.toLowerCase().replace(/^www\./, "");

const scrubTemplateTokens = (value) =>
  typeof value === "string" ? value.replace(/\{[^}]+\}/g, "placeholder") : value;

const extractHost = (raw) => {
  if (!raw || typeof raw !== "string") return null;
  const trimmed = raw.trim();
  if (!trimmed || !HTTP_REGEX.test(trimmed)) return null;

  try {
    const url = new URL(scrubTemplateTokens(trimmed));
    const protocol = url.protocol.toLowerCase();
    if (protocol !== "https:" && protocol !== "http:") {
      return null;
    }
    return normalizeHost(url.hostname);
  } catch {
    return null;
  }
};

const data = JSON.parse(fs.readFileSync(PROVIDERS_JSON, "utf8"));

const hostMap = new Map();
const providersMissingHosts = new Set();

for (const country of data.countries ?? []) {
  for (const provider of country.providers ?? []) {
    const set =
      hostMap.get(provider.id) ?? new Set();

    const candidates = [
      provider.deeplink_template,
      provider.coverage_url,
      ...(provider.regulator_links ?? []),
    ];

    for (const candidate of candidates) {
      const host = extractHost(candidate);
      if (host) {
        set.add(host);
      }
    }

    if (set.size === 0) {
      providersMissingHosts.add(provider.id);
    } else {
      providersMissingHosts.delete(provider.id);
      hostMap.set(provider.id, set);
    }
  }
}

if (providersMissingHosts.size > 0) {
  console.warn(
    "[sync-onramp-allowlist] Providers missing resolvable hosts:",
    Array.from(providersMissingHosts).sort().join(", ")
  );
}

const sortedEntries = Array.from(hostMap.entries())
  .map(([id, set]) => [id, Array.from(set).sort()])
  .sort(([a], [b]) => a.localeCompare(b));

const tsPayload =
  `// AUTO-GENERATED by scripts/sync-onramp-allowlist.js. Do not edit directly.\n` +
  `export const ALLOWED_PROVIDER_HOSTS = ${JSON.stringify(
    Object.fromEntries(sortedEntries),
    null,
    2
  )} as const;\n` +
  `export type AllowedProviderId = keyof typeof ALLOWED_PROVIDER_HOSTS;\n` +
  `export type AllowedProviderHosts = typeof ALLOWED_PROVIDER_HOSTS;\n`;

for (const target of [FRONTEND_TARGET, API_TARGET]) {
  fs.mkdirSync(path.dirname(target), { recursive: true });
  fs.writeFileSync(target, tsPayload, "utf8");
  const relBase =
    target.startsWith(API_ROOT) ? API_ROOT : WORKSPACE_ROOT;
  console.log(
    `[sync-onramp-allowlist] Wrote ${path.relative(relBase, target)}`
  );
}
